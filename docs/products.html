<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>OBAMA NEXT information products</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-dfb324f25d9b1687192fa8be62ac8f9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./img/logo-4-300x226.jpg" alt="OBAMA-NEXT logo" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./products.html" aria-current="page"> 
<span class="menu-text">Products</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blueprint.html"> 
<span class="menu-text">Blueprint</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#coastal-vegetation-mapping-using-remote-sensing" id="toc-coastal-vegetation-mapping-using-remote-sensing" class="nav-link active" data-scroll-target="#coastal-vegetation-mapping-using-remote-sensing">Coastal Vegetation Mapping Using Remote Sensing</a></li>
  <li><a href="#species-distribution-models-for-threatened-habitats-and-species" id="toc-species-distribution-models-for-threatened-habitats-and-species" class="nav-link" data-scroll-target="#species-distribution-models-for-threatened-habitats-and-species">Species Distribution Models for Threatened Habitats and Species</a></li>
  <li><a href="#habitat-suitability-modelling-of-marine-mammals" id="toc-habitat-suitability-modelling-of-marine-mammals" class="nav-link" data-scroll-target="#habitat-suitability-modelling-of-marine-mammals">Habitat Suitability Modelling of Marine Mammals</a></li>
  <li><a href="#high-resolution-predictive-maps-of-processes-underlying-fish-reproduction" id="toc-high-resolution-predictive-maps-of-processes-underlying-fish-reproduction" class="nav-link" data-scroll-target="#high-resolution-predictive-maps-of-processes-underlying-fish-reproduction">High-Resolution Predictive Maps of Processes Underlying Fish Reproduction</a></li>
  <li><a href="#detecting-and-quantifying-macroplastic-on-beaches-using-drones-and-ai" id="toc-detecting-and-quantifying-macroplastic-on-beaches-using-drones-and-ai" class="nav-link" data-scroll-target="#detecting-and-quantifying-macroplastic-on-beaches-using-drones-and-ai">Detecting and Quantifying Macroplastic on Beaches using Drones and AI</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">OBAMA NEXT information products</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Information products (IPs) developed.</p>
<section id="coastal-vegetation-mapping-using-remote-sensing" class="level3">
<h3 class="anchored" data-anchor-id="coastal-vegetation-mapping-using-remote-sensing">Coastal Vegetation Mapping Using Remote Sensing</h3>
<p>High-resolution drone-based mapping of coastal vegetation, including <em>in situ</em> ground truthing, model training, testing and validation.</p>
<p>Read more about this topic on <a href="https://obama-next.eu/information-products/#CoastalVegetation">OBAMA NEXT project website</a>.</p>
<ul>
<li><p><strong>IP1 - Seagrass mapping – distributions and ecological status</strong> - Drone-based seagrass mapping, including in situ ground truthing, model training (ML), testing and validation. The code repository is hosted at the SeaBee github organization <a href="https://github.com/SeaBee-no/">here</a></p></li>
<li><p><strong>IP2 - Coastal vegetation mapping – upscaled from drones to satellites</strong> - Fusion of high-resolution, small scale drone data and lower-resolution, large scale satellite images for upscaling of coastal vegetation maps (macroalgae, seagrass, bivalves, etc.). The code repository is hosted at the SeaBee github organization <a href="https://github.com/SeaBee-no/">here</a></p></li>
<li><p><strong>IP43 - Eelgrass SDM</strong> - A map predicting distribution of habitats of important WFD indicator species <em>Zostera marina</em> in Danish waters. Based on Machine Learning statistical approach (Random Forest model) using data layers including eelgrass coverage data from Danish monitoring program together with environmental data layers such as maximum wave exposure, temperature, light at seabed and Sediment. The code repository is <a href="https://github.com/OBAMANEXT/SDM_eelgrass_IP43/">here</a></p></li>
</ul>
<p>The modelling results are available on the OBAMA-NEXT data viewer <a href="https://data.openearth.nl/obama-next/?folders=Bj0nUGbDR66hSObRtygOdg&amp;layers=PouGnaiETDOqhOnMZtCR3A&amp;layerNames=Species%20Distribution%20Model%20for%20eelgrass%20-%20Kattegat">here</a></p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src=".\img/eelgrass_SDM.PNG" class="img-fluid figure-img"></p>
<figcaption>Predicted eelgrass distribution</figcaption>
</figure>
</div>
<ul>
<li><strong>IP26 - Mapping of biomass and carbon content of coastal vegetation using green LiDAR on drones</strong> - The use of LiDAR technology to precisely estimate the volume and biomass of submerged vegetation (seagrass, macroalgae, etc.) in the coastal zone. Carbon stock can be estimated. Compared to other drone products that are using RGB and MSI sensors (see IP-1 and IP-2), LiDAR’s can deliver volume data of vegetation from distribution and canopy height. Going from 2D (see IP-4) to 3D gives a more detailed and accurat estimat of the above-ground carbon stock of important species and habitat types, such as seagrass meadows, macroalgae beds, and kelp forests. The volume of these habitats are also tightly correlated to other ecosystem services, such as coastal protection and biodiversity. The code repository is hosted <a href="https://github.com/charles-patrick-lavin/NIVA-SeaBee-LiDAR/">here</a></li>
</ul>
</section>
<section id="species-distribution-models-for-threatened-habitats-and-species" class="level3">
<h3 class="anchored" data-anchor-id="species-distribution-models-for-threatened-habitats-and-species">Species Distribution Models for Threatened Habitats and Species</h3>
<p>High resolution spatial predictions on the occurrence of threatened species.</p>
<p>Technologies: Machine Learning, Statistical Modelling, In situ data collected by divers and drop-video</p>
<p>Relevant to Policies: Habitats Directive, Marine Strategy Framework Directive, European Biodiversity Strategy, Global Biodiversity Framework</p>
<ul>
<li><strong>IP9 - Population estimates of seabirds based on drone images and object recognition (AI/ML)</strong> - Population estimates of seabird colonies, including information on species, age, sex, nesting status, and feeding activity. To replace ineffective methods using airplanes and manual bird counting. The code repository is hosted at the SeaBee github organization <a href="https://github.com/SeaBee-no/">here</a></li>
</ul>
</section>
<section id="habitat-suitability-modelling-of-marine-mammals" class="level3">
<h3 class="anchored" data-anchor-id="habitat-suitability-modelling-of-marine-mammals">Habitat Suitability Modelling of Marine Mammals</h3>
<p>Maps of habitat suitability and use for these marine mammal species can show how ecosystems respond to environmental change and the effectiveness of conservation actions.</p>
<p>Read more about this topic on <a href="https://obama-next.eu/information-products/#MarineMammals">OBAMA NEXT project website</a>.</p>
<ul>
<li><strong>IP18 - Porpoise SDM</strong> - The code reads the harbour porpoise tracking data (based on ARGOS tags), cleans the Argos data, and performs a MaxEnt analyses to generate habitat suitability layers for one season and period (out of 6). Raster data is based on Copernicus data, which is freely available but also provided in the raster folder. To generate habitat suitability layers for all season and periods described in the article, adjust the code to the season and period of interest and rerun the procedure. See the code <a href="https://github.com/OBAMANEXT/SDM_porpoise_IP18">here</a>.</li>
</ul>
</section>
<section id="high-resolution-predictive-maps-of-processes-underlying-fish-reproduction" class="level3">
<h3 class="anchored" data-anchor-id="high-resolution-predictive-maps-of-processes-underlying-fish-reproduction">High-Resolution Predictive Maps of Processes Underlying Fish Reproduction</h3>
<p>The model integrates different types of fisheries and survey data and returns estimates of how different processes underlying animal’s reproduction cycle are affected by environmental conditions at a local scale, as well as predictive maps of animal and underlying reproduction processes distribution along the area of interest. The model applies to the Baltic whitefish.</p>
<p>Read more about this topic on <a href="https://obama-next.eu/information-products/#FishReproduction">OBAMA NEXT project website</a>.</p>
<p><a href="https://github.com/OBAMANEXT/">…link to repository to come</a></p>
</section>
<section id="detecting-and-quantifying-macroplastic-on-beaches-using-drones-and-ai" class="level3">
<h3 class="anchored" data-anchor-id="detecting-and-quantifying-macroplastic-on-beaches-using-drones-and-ai">Detecting and Quantifying Macroplastic on Beaches using Drones and AI</h3>
<p>This IP describes how drones equipped with advanced sensors can be used to detect macroplastics on beaches. Artificial Intelligence is used to quantify the amount of litter, for instance before and after a beach clean-up event. The SeaBee drone infrastructure has done proof-of-concept studies on this, which still remains to be included in monitoring.</p>
<p>Read more about this topic on <a href="https://obama-next.eu/information-products/#Macroplastics">OBAMA NEXT project website</a>.</p>
<p><a href="https://github.com/OBAMANEXT/">…link to repository to come</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>